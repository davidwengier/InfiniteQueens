@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using InfiniteQueens.Models
@using InfiniteQueens.Services
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject GameHistory GameHistory
@inject BoardGenerator BoardGenerator
@implements IDisposable

@page "/"

<PageTitle>Infinite Queens</PageTitle>

<div class="game-container">
    <HistoryPane 
        ShowHistory="@timedMode" 
        HasHistory="@GameHistory.HasHistory(boardSize)"
        BoardSize="@boardSize"
        History="@GameHistory.GetHistory(boardSize)" />
    
    <h1>Infinite Queens</h1>
    <p>Place one queen in each coloured region. No two queens can share a row, column, or be diagonally adjacent.</p>
    <p style="font-size: 14px; color: #888;">Click once for ✕ (mark), twice for ♛ (queen), three times to clear.</p>
    
    <div class="controls">
        <TimerDisplay ShowTimer="@timedMode" ElapsedTime="@elapsedTime" />
        <SizeSelector 
            CurrentSize="@boardSize" 
            OnSizeChanged="@ChangeBoardSize"
            Disabled="@isGenerating" />
        <select @bind="difficulty" disabled="@isGenerating" class="difficulty-selector">
            <option value="@Difficulty.Easy">Easy</option>
            <option value="@Difficulty.Medium">Medium</option>
            <option value="@Difficulty.Hard">Hard</option>
        </select>
        <button @onclick="ClearBoard" disabled="@isGenerating">Clear</button>
    </div>

    <GenerationStatus 
        IsGenerating="@isGenerating"
        BoardSize="@boardSize"
        CurrentAttempt="@currentAttempt"
        LogEntries="@generationLog" />

    @if (!isGenerating && currentGameNumber > 0)
    {
        <h2 style="margin-top: 20px; color: #2196F3;">@(boardSize)x@(boardSize) Game #@currentGameNumber</h2>
    }

    <GameBoard 
        BoardSize="@boardSize"
        IsHidden="@isGenerating"
        GameState="@gameState"
        OnCellClick="@((coords) => ToggleQueen(coords.row, coords.col))"
        OnCellPointerDown="@((args) => HandleCellPointerDown(args.e, args.row, args.col))"
        OnCellPointerEnter="@((coords) => HandleCellPointerEnter(coords.row, coords.col))"
        OnBoardPointerMove="@HandleBoardPointerMove"
        OnCellPointerUp="@HandleCellPointerUp" />

    <div class="toggles-container">
        <ToggleSwitch 
            Label="Auto-mark invalid squares"
            IsChecked="@autoMarkInvalid"
            Disabled="@isGenerating"
            OnToggle="@ToggleAutoMark" />
        
        <ToggleSwitch 
            Label="Timed games"
            IsChecked="@timedMode"
            OnToggle="@ToggleTimedMode" />
    </div>

    <WinOverlay 
        IsVisible="@(gameState.CheckWin() || isGameWon)"
        ShowTime="@timedMode"
        CompletionTime="@(completionTime.HasValue ? completionTime : elapsedTime)"
        OnClose="@CloseWinOverlay"
        OnNewGame="@StartNewGame" />
</div>

@code {
    private int boardSize = 6;
    private GameState gameState = null!;
    private bool autoMarkInvalid = true;
    private bool isGenerating = false;
    private System.Timers.Timer? gameTimer;
    private DateTime gameStartTime;
    private TimeSpan elapsedTime;
    private TimeSpan? completionTime;
    private bool isGameWon = false;
    private List<string> generationLog = new List<string>();
    private int currentAttempt = 0;
    private int currentGameNumber = 0;
    private bool timedMode = true;
    private Difficulty difficulty = Difficulty.Medium;
    private bool pointerIsDown = false;
    private (int row, int col)? pointerDownCell = null;
    private HashSet<(int row, int col)> draggedCells = new HashSet<(int, int)>();
    private bool wasDragging = false; // Track if we actually dragged vs just tapped

    protected override void OnInitialized()
    {
        // Read board size from URL parameter
        var uri = new Uri(NavigationManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        var sizeParam = query["size"];
        var testWin = query["testWin"];
        
        if (!string.IsNullOrEmpty(sizeParam) && int.TryParse(sizeParam, out int size))
        {
            if (size >= 4 && size <= 10)
            {
                boardSize = size;
            }
        }
        
        gameState = new GameState(boardSize);
        
        // Test mode: show win state immediately
        if (!string.IsNullOrEmpty(testWin) && testWin == "true")
        {
            isGameWon = true;
            completionTime = TimeSpan.FromSeconds(42);
            // Don't call ResetGame in test mode
        }
        else
        {
            ResetGame();
        }
    }

    public void Dispose()
    {
        gameTimer?.Stop();
        gameTimer?.Dispose();
    }

    private void StartTimer()
    {
        if (!timedMode)
            return;
            
        completionTime = null;
        isGameWon = false;
        gameStartTime = DateTime.Now;
        elapsedTime = TimeSpan.Zero;
        
        gameTimer?.Stop();
        gameTimer = new System.Timers.Timer(100); // Update every 100ms for smooth display
        gameTimer.Elapsed += (sender, e) =>
        {
            if (!isGameWon)
            {
                elapsedTime = DateTime.Now - gameStartTime;
                InvokeAsync(StateHasChanged);
            }
        };
        gameTimer.Start();
    }

    private void StopTimer()
    {
        gameTimer?.Stop();
        completionTime = elapsedTime;
        isGameWon = true;
        
        // Only add to game history if in timed mode
        if (timedMode)
        {
            GameHistory.AddResult(boardSize, currentGameNumber, completionTime.Value);
        }
    }

    private string FormatTime(TimeSpan time)
    {
        if (time.TotalHours >= 1)
            return $"{(int)time.TotalHours}:{time.Minutes:D2}:{time.Seconds:D2}";
        else
            return $"{time.Minutes}:{time.Seconds:D2}";
    }

    private async Task ChangeBoardSize(int newSize)
    {
        // If clicking current size, treat it as "New Game"
        bool isSameSize = (newSize == boardSize);

        // Check if user has placed anything (and game is not won)
        bool hasPlacedPieces = false;
        if (!isGameWon)
        {
            for (int r = 0; r < boardSize; r++)
            {
                for (int c = 0; c < boardSize; c++)
                {
                    if (gameState.Board[r, c] != CellState.Empty)
                    {
                        hasPlacedPieces = true;
                        break;
                    }
                }
                if (hasPlacedPieces) break;
            }
        }

        // Ask for confirmation if pieces are placed and game is not won
        if (hasPlacedPieces)
        {
            string message = isSameSize 
                ? "Generate a new puzzle? Your current progress will be lost." 
                : "Changing board size will clear your current progress. Continue?";
            
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", message);
            if (!confirmed)
                return;
        }

        // Update size and create new game state
        boardSize = newSize;
        gameState = new GameState(boardSize);
        
        // Update URL with new size
        NavigationManager.NavigateTo($"?size={boardSize}", false);
        
        // Now show spinner and generate
        isGenerating = true;
        StateHasChanged();
        await Task.Delay(100);

        await ResetGameAsync();
    }

    private async void ResetGame()
    {
        await ChangeBoardSize(boardSize);
    }

    private async Task ResetGameAsync()
    {
        // Don't set isGenerating again if already set by ChangeBoardSize
        if (!isGenerating)
        {
            isGenerating = true;
            StateHasChanged();
            await Task.Delay(100);
        }

        // Increment game counter for this board size
        currentGameNumber = GameHistory.GetNextGameNumber(boardSize);

        generationLog.Clear();
        currentAttempt = 0;
        
        bool foundValid = false;
        
        await Task.Run(async () =>
        {
            int maxAttempts = boardSize >= 10 ? 50 : 100;
            
            for (int attempts = 0; attempts < maxAttempts; attempts++)
            {
                int attemptNum = attempts + 1;
                currentAttempt = attemptNum;
                
                await InvokeAsync(() =>
                {
                    AddLog($"Attempt {attemptNum}: Generating regions...");
                    StateHasChanged();
                });
                
                await Task.Delay(20); // Small delay for UI update
                
                var regions = BoardGenerator.GenerateRegions(boardSize);
                
                await InvokeAsync(() =>
                {
                    AddLog($"Attempt {attemptNum}: Validating...");
                    StateHasChanged();
                });
                
                await Task.Delay(20); // Small delay for UI update
                
                if (BoardGenerator.IsSolvableWithDifficulty(regions, boardSize, difficulty))
                {
                    await InvokeAsync(() =>
                    {
                        gameState.SetRegions(regions);
                        AddLog($"✓ Attempt {attemptNum}: Valid {difficulty} board found!");
                        foundValid = true;
                        StateHasChanged();
                    });
                    break;
                }
                else
                {
                    await InvokeAsync(() =>
                    {
                        AddLog($"✗ Attempt {attemptNum}: Invalid difficulty or no unique solution");
                        StateHasChanged();
                    });
                }
                
                await Task.Delay(20); // Small delay between attempts
            }
            
            if (!foundValid)
            {
                await InvokeAsync(() =>
                {
                    AddLog($"⚠ Using best attempt after {currentAttempt} tries");
                    StateHasChanged();
                });
            }
        });

        isGenerating = false;
        StateHasChanged();
        
        // Start the timer after board is generated
        StartTimer();
    }
     
    private void AddLog(string message)
    {
        generationLog.Add(message);
        // Keep up to 50 messages for better scrolling effect
        if (generationLog.Count > 50)
            generationLog.RemoveAt(0);
    }

    private void ToggleQueen(int row, int col)
    {
        // Ignore clicks if game is won or if we just did a drag operation
        if (isGameWon)
            return;
            
        // If we just finished a drag, ignore this click and clear the flag
        if (wasDragging)
        {
            wasDragging = false;
            StateHasChanged(); // Force UI update after clearing drag state
            return;
        }
            
        var oldState = gameState.GetCell(row, col);
        bool wasAutoMark = gameState.GetAutoMark(row, col);
        
        // If clicking on an auto-mark, convert it to manual mark
        if (wasAutoMark && oldState == CellState.Empty)
        {
            gameState.SetAutoMark(row, col, false);
            gameState.SetCell(row, col, CellState.ManualCross);
            return;
        }
        
        // If this was a queen being removed, clear its auto-marks
        if (oldState == CellState.Queen)
        {
            gameState.RemoveAutoMarksFromQueen(row, col);
        }
        
        // Cycle through: Empty -> ManualCross -> Queen -> Empty
        var nextState = oldState switch
        {
            CellState.Empty => CellState.ManualCross,
            CellState.ManualCross => CellState.Queen,
            CellState.Queen => CellState.Empty,
            _ => CellState.Empty
        };
        gameState.SetCell(row, col, nextState);
        
        // If we just placed a queen and auto-mark is enabled, mark invalid squares
        if (autoMarkInvalid && oldState != CellState.Queen && nextState == CellState.Queen)
        {
            gameState.AutoMarkInvalidSquares(row, col);
        }
        
        // Check for win condition
        if (!isGameWon && gameState.CheckWin())
        {
            StopTimer();
        }
    }
    
    private void ToggleAutoMark()
    {
        if (!isGenerating)
        {
            autoMarkInvalid = !autoMarkInvalid;
        }
    }
    
    private void ToggleTimedMode()
    {
        timedMode = !timedMode;
    }
    
    private void CloseWinOverlay()
    {
        // Clicking on the overlay background closes it
        isGameWon = false;
    }
    
    private async void StartNewGame()
    {
        // Close the overlay and start a new game (no confirmation needed)
        completionTime = null;
        
        // Generate new game directly without confirmation
        gameState = new GameState(boardSize);
        
        isGenerating = true;
        isGameWon = false;
        StateHasChanged();
        await Task.Delay(100);

        await ResetGameAsync();
    }
    
    private async void ClearBoard()
    {
        // Check if user has placed anything
        bool hasPlacedPieces = false;
        if (!isGameWon)
        {
            for (int r = 0; r < boardSize; r++)
            {
                for (int c = 0; c < boardSize; c++)
                {
                    if (gameState.Board[r, c] != CellState.Empty)
                    {
                        hasPlacedPieces = true;
                        break;
                    }
                }
                if (hasPlacedPieces) break;
            }
        }

        // Ask for confirmation if pieces are placed
        if (hasPlacedPieces)
        {
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Clear all your marks and start fresh on this board?");
            if (!confirmed)
                return;
        }

        // Clear the board without regenerating
        for (int r = 0; r < boardSize; r++)
        {
            for (int c = 0; c < boardSize; c++)
            {
                gameState.SetCell(r, c, CellState.Empty);
                gameState.SetAutoMark(r, c, false);
            }
        }
        
        // Restart the timer
        if (timedMode)
        {
            StartTimer();
        }
    }
    
    private void HandleCellPointerDown(PointerEventArgs e, int row, int col)
    {
        if (isGameWon)
            return;
            
        pointerIsDown = true;
        pointerDownCell = (row, col);
    }
    
    private void HandleCellPointerEnter(int row, int col)
    {
        if (!pointerIsDown || isGameWon)
            return;
            
        // We've moved to a different cell - this is a drag operation
        if (pointerDownCell.HasValue)
        {
            // Mark the initial cell if we haven't already
            if (draggedCells.Count == 0)
            {
                draggedCells.Add(pointerDownCell.Value);
                PlaceMarkIfEmpty(pointerDownCell.Value.row, pointerDownCell.Value.col);
            }
        }
        
        // Only mark if we haven't marked this cell yet during this drag
        if (draggedCells.Add((row, col)))
        {
            wasDragging = true; // We're now dragging across cells
            PlaceMarkIfEmpty(row, col);
        }
    }
    
    private async Task HandleBoardPointerMove(PointerEventArgs e)
    {
        // For touch devices, we need to use the board-level pointermove to track dragging
        if (e.PointerType == "touch" && pointerIsDown && !isGameWon)
        {
            try
            {
                // Use JS to find which cell element is under the pointer
                var result = await JSRuntime.InvokeAsync<int[]>("getCellAtPoint", e.ClientX, e.ClientY);
                if (result != null && result.Length == 2)
                {
                    int row = result[0];
                    int col = result[1];
                    
                    // Only mark if we haven't marked this cell yet during this drag
                    if (draggedCells.Add((row, col)))
                    {
                        wasDragging = true; // We're now dragging across cells
                        PlaceMarkIfEmpty(row, col);
                    }
                }
            }
            catch
            {
                // Ignore errors - pointer might be outside the board
            }
        }
    }
    
    private void HandleCellPointerUp()
    {
        pointerIsDown = false;
        pointerDownCell = null;
        draggedCells.Clear(); // Clear drag state so next click isn't consumed
    }
    
    private void PlaceMarkIfEmpty(int row, int col)
    {
        var cellState = gameState.GetCell(row, col);
        bool isAutoMark = gameState.GetAutoMark(row, col);
        
        // Only place marks on empty cells or auto-marks, don't overwrite queens or existing manual marks
        if (cellState == CellState.Empty && !isAutoMark)
        {
            gameState.SetCell(row, col, CellState.ManualCross);
        }
        else if (isAutoMark && cellState == CellState.Empty)
        {
            gameState.SetAutoMark(row, col, false);
            gameState.SetCell(row, col, CellState.ManualCross);
        }
    }
}
