@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using InfiniteQueens.Models
@using InfiniteQueens.Services
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject GameHistory GameHistory
@inject BoardGenerator BoardGenerator
@implements IDisposable

@page "/"

<PageTitle>Infinite Queens</PageTitle>

<div class="game-container">
    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
        <h1 style="margin: 0;">Infinite Queens</h1>
        <div class="help-button" tabindex="0">
            <span class="help-icon">?</span>
            <div class="help-tooltip">
                <strong>How to Play:</strong><br/>
                Place one queen in each coloured region.<br/>
                <br/>
                <strong>Rules:</strong><br/>
                • No two queens in same row or column<br/>
                • No diagonally adjacent queens<br/>
                <br/>
                <strong>Controls:</strong><br/>
                Click once: ✕ (mark)<br/>
                Click twice: ♛ (queen)<br/>
                Click three times: clear
            </div>
        </div>
    </div>
    
    <div class="controls">
        <SizeSelector 
            CurrentSize="@boardSize" 
            OnSizeChanged="@ChangeBoardSize"
            Disabled="@isGenerating" />
        <button @onclick="ClearBoard" disabled="@isGenerating">Clear</button>
    </div>

    <GenerationStatus 
        IsGenerating="@isGenerating"
        BoardSize="@boardSize"
        CurrentAttempt="@currentAttempt"
        LogEntries="@generationLog" />

    @if (!isGenerating && currentGameNumber > 0)
    {
        <h2 style="margin-top: 20px; color: #2196F3;">@(boardSize)x@(boardSize) Game #@currentGameNumber</h2>
        @if (currentSeed.HasValue)
        {
            <div style="font-size: 14px; color: #888; margin-top: 5px;">
                Seed: <span style="font-family: monospace; color: #2196F3;">@currentSeed.Value</span>
            </div>
        }
        @if (!string.IsNullOrEmpty(currentBoardHash))
        {
            <div style="font-size: 12px; color: #aaa; margin-top: 3px;">
                Hash: <span style="font-family: monospace;">@currentBoardHash</span>
            </div>
        }
        <TimerDisplay ShowTimer="@timedMode" ElapsedTime="@elapsedTime" />
    }
    else if (!isGenerating && currentGameNumber == 0 && currentSeed.HasValue)
    {
        <h2 style="margin-top: 20px; color: #2196F3;">@(boardSize)x@(boardSize) Shared Game</h2>
        <div style="font-size: 14px; color: #888; margin-top: 5px;">
            Seed: <span style="font-family: monospace; color: #2196F3;">@currentSeed.Value</span>
        </div>
        @if (!string.IsNullOrEmpty(currentBoardHash))
        {
            <div style="font-size: 12px; color: #aaa; margin-top: 3px;">
                Hash: <span style="font-family: monospace;">@currentBoardHash</span>
            </div>
        }
        <TimerDisplay ShowTimer="@timedMode" ElapsedTime="@elapsedTime" />
    }

    <GameBoard 
        BoardSize="@boardSize"
        IsHidden="@isGenerating"
        GameState="@gameState"
        OnCellClick="@((coords) => ToggleQueen(coords.row, coords.col))"
        OnCellPointerDown="@((args) => HandleCellPointerDown(args.e, args.row, args.col))"
        OnCellPointerEnter="@((coords) => HandleCellPointerEnter(coords.row, coords.col))"
        OnBoardPointerMove="@HandleBoardPointerMove"
        OnCellPointerUp="@HandleCellPointerUp" />

    <div class="toggles-container">
        <ToggleSwitch 
            Label="Auto-mark invalid squares"
            IsChecked="@autoMarkInvalid"
            Disabled="@isGenerating"
            OnToggle="@ToggleAutoMark" />
        
        <ToggleSwitch 
            Label="Timed games"
            IsChecked="@timedMode"
            OnToggle="@ToggleTimedMode" />
    </div>

    <HistoryPane 
        ShowHistory="@timedMode" 
        HasHistory="@GameHistory.HasHistory(boardSize)"
        BoardSize="@boardSize"
        History="@GameHistory.GetHistory(boardSize)" />

    <WinOverlay 
        IsVisible="@(gameState.CheckWin() || isGameWon)"
        ShowTime="@timedMode"
        CompletionTime="@(completionTime.HasValue ? completionTime : elapsedTime)"
        BoardHash="@currentBoardHash"
        PreviousGame="@previousGameWithSameBoard"
        OnClose="@CloseWinOverlay"
        OnNewGame="@StartNewGame" />
</div>

@code {
    private int boardSize = 6;
    private GameState gameState = null!;
    private bool autoMarkInvalid = true;
    private bool isGenerating = false;
    private System.Timers.Timer? gameTimer;
    private DateTime gameStartTime;
    private TimeSpan elapsedTime;
    private TimeSpan? completionTime;
    private bool isGameWon = false;
    private List<string> generationLog = new List<string>();
    private int currentAttempt = 0;
    private int currentGameNumber = 0;
    private bool timedMode = true;
    private bool pointerIsDown = false;
    private (int row, int col)? pointerDownCell = null;
    private HashSet<(int row, int col)> draggedCells = new HashSet<(int, int)>();
    private bool wasDragging = false; // Track if we actually dragged vs just tapped
    private string? currentBoardHash = null;
    private GameResult? previousGameWithSameBoard = null;
    private int? currentSeed = null;
    private bool isLoadingFromUrlSeed = false; // Track if current seed is from URL parameter
    private DotNetObjectReference<Home>? dotNetHelper;

    protected override void OnInitialized()
    {
        // Read board size and seed from URL parameters
        var uri = new Uri(NavigationManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        var sizeParam = query["size"];
        var seedParam = query["seed"];
        var testWin = query["testWin"];
        
        if (!string.IsNullOrEmpty(sizeParam) && int.TryParse(sizeParam, out int size))
        {
            if (size >= 5 && size <= 10)
            {
                boardSize = size;
            }
        }
        
        // Check if a seed is specified
        if (!string.IsNullOrEmpty(seedParam) && int.TryParse(seedParam, out int seed))
        {
            currentSeed = seed;
            isLoadingFromUrlSeed = true; // Mark that we're loading from URL
        }
        
        gameState = new GameState(boardSize);
        
        // Test mode: show win state immediately
        if (!string.IsNullOrEmpty(testWin) && testWin == "true")
        {
            isGameWon = true;
            completionTime = TimeSpan.FromSeconds(42);
            // Don't call ResetGame in test mode
        }
        else
        {
            ResetGame();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("setupGlobalPointerHandlers", dotNetHelper);
        }
    }

    public void Dispose()
    {
        gameTimer?.Stop();
        gameTimer?.Dispose();
        dotNetHelper?.Dispose();
    }

    [JSInvokable]
    public void HandleGlobalPointerUp()
    {
        HandleCellPointerUp();
    }

    private void StartTimer()
    {
        if (!timedMode)
            return;
            
        completionTime = null;
        isGameWon = false;
        gameStartTime = DateTime.Now;
        elapsedTime = TimeSpan.Zero;
        
        gameTimer?.Stop();
        gameTimer = new System.Timers.Timer(100); // Update every 100ms for smooth display
        gameTimer.Elapsed += (sender, e) =>
        {
            if (!isGameWon)
            {
                elapsedTime = DateTime.Now - gameStartTime;
                InvokeAsync(StateHasChanged);
            }
        };
        gameTimer.Start();
    }

    private void StopTimer()
    {
        gameTimer?.Stop();
        completionTime = elapsedTime;
        isGameWon = true;
        
        // Only add to game history if in timed mode
        if (timedMode && currentSeed.HasValue)
        {
            string boardHash = gameState.GetBoardHash();
            
            // Check if this board was played before
            previousGameWithSameBoard = GameHistory.FindPreviousGameByHash(boardSize, boardHash);
            
            GameHistory.AddResult(boardSize, currentGameNumber, completionTime.Value, boardHash, currentSeed.Value);
        }
    }

    private string FormatTime(TimeSpan time)
    {
        if (time.TotalHours >= 1)
            return $"{(int)time.TotalHours}:{time.Minutes:D2}:{time.Seconds:D2}";
        else
            return $"{time.Minutes}:{time.Seconds:D2}";
    }

    private async Task ChangeBoardSize(int newSize)
    {
        // If clicking current size, treat it as "New Game"
        bool isSameSize = (newSize == boardSize);

        // Check if user has placed anything (and game is not won)
        bool hasPlacedPieces = false;
        if (!isGameWon)
        {
            for (int r = 0; r < boardSize; r++)
            {
                for (int c = 0; c < boardSize; c++)
                {
                    if (gameState.Board[r, c] != CellState.Empty)
                    {
                        hasPlacedPieces = true;
                        break;
                    }
                }
                if (hasPlacedPieces) break;
            }
        }

        // Ask for confirmation if pieces are placed and game is not won
        if (hasPlacedPieces)
        {
            string message = isSameSize 
                ? "Generate a new puzzle? Your current progress will be lost." 
                : "Changing board size will clear your current progress. Continue?";
            
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", message);
            if (!confirmed)
                return;
        }

        // Update size and create new game state
        boardSize = newSize;
        gameState = new GameState(boardSize);
        
        // Update URL with new size (clear any seed since we're generating a new board)
        NavigationManager.NavigateTo($"?size={boardSize}", replace: true);
        
        // Now show spinner and generate
        isGenerating = true;
        StateHasChanged();
        await Task.Delay(100);

        await ResetGameAsync();
    }

    private async void ResetGame()
    {
        await ChangeBoardSize(boardSize);
    }

    private async Task ResetGameAsync()
    {
        // Don't set isGenerating again if already set by ChangeBoardSize
        if (!isGenerating)
        {
            isGenerating = true;
            StateHasChanged();
            await Task.Delay(100);
        }

        // Check if we're loading from a URL seed parameter (only true on first load)
        bool loadingFromUrlSeed = isLoadingFromUrlSeed;
        isLoadingFromUrlSeed = false; // Clear flag after checking
        
        // Increment game counter for this board size (unless loading from URL seed)
        if (!loadingFromUrlSeed)
        {
            currentGameNumber = GameHistory.GetNextGameNumber(boardSize);
        }
        else
        {
            // For URL-seeded games, use 0 to indicate it's a shared/seed game
            currentGameNumber = 0;
        }

        generationLog.Clear();
        currentAttempt = 0;
        
        bool foundValid = false;
        int? usedSeed = null;
        
        // If we have a seed from URL, use it directly
        if (loadingFromUrlSeed && currentSeed.HasValue)
        {
            int seedValue = currentSeed.Value;
            usedSeed = seedValue;
            await Task.Run(async () =>
            {
                await InvokeAsync(() =>
                {
                    AddLog($"Loading board from seed {seedValue}...");
                    StateHasChanged();
                });
                
                await Task.Delay(20);
                
                var regions = BoardGenerator.GenerateRegions(boardSize, seedValue);
                
                await InvokeAsync(() =>
                {
                    gameState.SetRegions(regions);
                    AddLog($"✓ Board loaded!");
                    foundValid = true;
                    StateHasChanged();
                });
            });
        }
        else
        {
            // Generate a random seed for a new game - always fresh each time
            usedSeed = new Random().Next();
            
            await Task.Run(async () =>
            {
                int maxAttempts = boardSize >= 10 ? 50 : 100;
                
                for (int attempts = 0; attempts < maxAttempts; attempts++)
                {
                    int attemptNum = attempts + 1;
                    currentAttempt = attemptNum;
                    
                    // Try different seeds until we find a solvable one
                    int trySeed = usedSeed.Value + attempts;
                    
                    await InvokeAsync(() =>
                    {
                        AddLog($"Attempt {attemptNum}: Generating regions...");
                        StateHasChanged();
                    });
                    
                    await Task.Delay(20); // Small delay for UI update
                    
                    var regions = BoardGenerator.GenerateRegions(boardSize, trySeed);
                    
                    await InvokeAsync(() =>
                    {
                        AddLog($"Attempt {attemptNum}: Validating...");
                        StateHasChanged();
                    });
                    
                    await Task.Delay(20); // Small delay for UI update
                    
                    if (BoardGenerator.IsSolvable(regions, boardSize))
                    {
                        usedSeed = trySeed; // Store the successful seed
                        await InvokeAsync(() =>
                        {
                            gameState.SetRegions(regions);
                            AddLog($"✓ Attempt {attemptNum}: Valid board found!");
                            foundValid = true;
                            StateHasChanged();
                        });
                        break;
                    }
                    else
                    {
                        await InvokeAsync(() =>
                        {
                            AddLog($"✗ Attempt {attemptNum}: Unsolvable");
                            StateHasChanged();
                        });
                    }
                    
                    await Task.Delay(20); // Small delay between attempts
                }
                
                if (!foundValid)
                {
                    await InvokeAsync(() =>
                    {
                        AddLog($"⚠ Using best attempt after {currentAttempt} tries");
                        StateHasChanged();
                    });
                }
            });
        }

        isGenerating = false;
        
        // Store the seed for display and saving (but NOT for reuse next game)
        // We use a separate variable to track the currently displayed seed
        currentSeed = usedSeed;
        
        // Calculate and store the board hash for the new game
        currentBoardHash = gameState.GetBoardHash();
        previousGameWithSameBoard = null; // Reset for new game
        
        StateHasChanged();
        
        // Start the timer after board is generated
        StartTimer();
    }
     
    private void AddLog(string message)
    {
        generationLog.Add(message);
        // Keep up to 50 messages for better scrolling effect
        if (generationLog.Count > 50)
            generationLog.RemoveAt(0);
    }

    private void ToggleQueen(int row, int col)
    {
        // Ignore clicks if game is won or if we just did a drag operation
        if (isGameWon)
            return;
            
        // If we just finished a drag, ignore this click and clear the flag
        if (wasDragging)
        {
            wasDragging = false;
            StateHasChanged(); // Force UI update after clearing drag state
            return;
        }
            
        var oldState = gameState.GetCell(row, col);
        bool wasAutoMark = gameState.GetAutoMark(row, col);
        
        // If clicking on an auto-mark, convert it to manual mark
        if (wasAutoMark && oldState == CellState.Empty)
        {
            gameState.SetAutoMark(row, col, false);
            gameState.SetCell(row, col, CellState.ManualCross);
            return;
        }
        
        // If this was a queen being removed, clear its auto-marks
        if (oldState == CellState.Queen)
        {
            gameState.RemoveAutoMarksFromQueen(row, col);
        }
        
        // Cycle through: Empty -> ManualCross -> Queen -> Empty
        var nextState = oldState switch
        {
            CellState.Empty => CellState.ManualCross,
            CellState.ManualCross => CellState.Queen,
            CellState.Queen => CellState.Empty,
            _ => CellState.Empty
        };
        gameState.SetCell(row, col, nextState);
        
        // If we just placed a queen and auto-mark is enabled, mark invalid squares
        if (autoMarkInvalid && oldState != CellState.Queen && nextState == CellState.Queen)
        {
            gameState.AutoMarkInvalidSquares(row, col);
        }
        
        // Check for win condition
        if (!isGameWon && gameState.CheckWin())
        {
            StopTimer();
        }
    }
    
    private void ToggleAutoMark()
    {
        if (!isGenerating)
        {
            autoMarkInvalid = !autoMarkInvalid;
        }
    }
    
    private void ToggleTimedMode()
    {
        timedMode = !timedMode;
    }
    
    private void CloseWinOverlay()
    {
        // Clicking on the overlay background closes it
        isGameWon = false;
    }
    
    private async void StartNewGame()
    {
        // Close the overlay and start a new game (no confirmation needed)
        completionTime = null;
        
        // Generate new game directly without confirmation
        gameState = new GameState(boardSize);
        
        isGenerating = true;
        isGameWon = false;
        StateHasChanged();
        await Task.Delay(100);

        await ResetGameAsync();
    }
    
    private async void ClearBoard()
    {
        // Check if user has placed anything
        bool hasPlacedPieces = false;
        if (!isGameWon)
        {
            for (int r = 0; r < boardSize; r++)
            {
                for (int c = 0; c < boardSize; c++)
                {
                    if (gameState.Board[r, c] != CellState.Empty)
                    {
                        hasPlacedPieces = true;
                        break;
                    }
                }
                if (hasPlacedPieces) break;
            }
        }

        // Ask for confirmation if pieces are placed
        if (hasPlacedPieces)
        {
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Clear all your marks and start fresh on this board?");
            if (!confirmed)
                return;
        }

        // Clear the board without regenerating
        for (int r = 0; r < boardSize; r++)
        {
            for (int c = 0; c < boardSize; c++)
            {
                gameState.SetCell(r, c, CellState.Empty);
                gameState.SetAutoMark(r, c, false);
            }
        }
        
        // Restart the timer
        if (timedMode)
        {
            StartTimer();
        }
    }
    
    private void HandleCellPointerDown(PointerEventArgs e, int row, int col)
    {
        if (isGameWon)
            return;
            
        pointerIsDown = true;
        pointerDownCell = (row, col);
    }
    
    private void HandleCellPointerEnter(int row, int col)
    {
        if (!pointerIsDown || isGameWon)
            return;
            
        // We've moved to a different cell - this is a drag operation
        if (pointerDownCell.HasValue)
        {
            // Mark the initial cell if we haven't already
            if (draggedCells.Count == 0)
            {
                draggedCells.Add(pointerDownCell.Value);
                PlaceMarkIfEmpty(pointerDownCell.Value.row, pointerDownCell.Value.col);
            }
        }
        
        // Only mark if we haven't marked this cell yet during this drag
        if (draggedCells.Add((row, col)))
        {
            wasDragging = true; // We're now dragging across cells
            PlaceMarkIfEmpty(row, col);
        }
    }
    
    private async Task HandleBoardPointerMove(PointerEventArgs e)
    {
        // For touch devices, we need to use the board-level pointermove to track dragging
        if (e.PointerType == "touch" && pointerIsDown && !isGameWon)
        {
            try
            {
                // Use JS to find which cell element is under the pointer
                var result = await JSRuntime.InvokeAsync<int[]>("getCellAtPoint", e.ClientX, e.ClientY);
                if (result != null && result.Length == 2)
                {
                    int row = result[0];
                    int col = result[1];
                    
                    // Only mark if we haven't marked this cell yet during this drag
                    if (draggedCells.Add((row, col)))
                    {
                        wasDragging = true; // We're now dragging across cells
                        PlaceMarkIfEmpty(row, col);
                    }
                }
            }
            catch
            {
                // Ignore errors - pointer might be outside the board
            }
        }
    }
    
    private void HandleCellPointerUp()
    {
        pointerIsDown = false;
        pointerDownCell = null;
        draggedCells.Clear();
        // Don't clear wasDragging here - let ToggleQueen check and clear it
        // This ensures that if we were dragging, the subsequent click is ignored
    }
    
    private void PlaceMarkIfEmpty(int row, int col)
    {
        var cellState = gameState.GetCell(row, col);
        bool isAutoMark = gameState.GetAutoMark(row, col);
        
        // Only place marks on empty cells or auto-marks, don't overwrite queens or existing manual marks
        if (cellState == CellState.Empty && !isAutoMark)
        {
            gameState.SetCell(row, col, CellState.ManualCross);
        }
        else if (isAutoMark && cellState == CellState.Empty)
        {
            gameState.SetAutoMark(row, col, false);
            gameState.SetCell(row, col, CellState.ManualCross);
        }
    }
}
