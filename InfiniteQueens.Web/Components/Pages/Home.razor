@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using InfiniteQueens.Models
@using InfiniteQueens.Services
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager
@inject GameHistory GameHistory
@inject BoardGenerator BoardGenerator
@implements IDisposable

@page "/"

<PageTitle>Infinite Queens</PageTitle>

<div class="game-container">
    @if (timedMode && GameHistory.HasHistory(boardSize))
    {
        <div class="history-pane">
            <h3>@(boardSize)x@(boardSize) Game History</h3>
            <div class="history-list">
                @foreach (var (game, index) in GameHistory.GetHistory(boardSize).Select((g, i) => (g, i)))
                {
                    <div class="history-item">
                        @if (index == 0)
                        {
                            <span class="medal">ü•á</span>
                        }
                        else if (index == 1)
                        {
                            <span class="medal">ü•à</span>
                        }
                        else if (index == 2)
                        {
                            <span class="medal">ü•â</span>
                        }
                        else
                        {
                            <span class="medal"></span>
                        }
                        <span class="game-num">Game #@game.GameNumber</span>
                        <span class="game-time">@FormatTime(game.Time)</span>
                    </div>
                }
            </div>
        </div>
    }
    
    <h1>Infinite Queens</h1>
    <p>Place one queen in each coloured region. No two queens can share a row, column, or be diagonally adjacent.</p>
    <p style="font-size: 14px; color: #888;">Click once for ‚úï (mark), twice for ‚ôõ (queen), three times to clear.</p>
    
    <div class="controls">
        @if (timedMode)
        {
            <div class="timer-display">
                ‚è±Ô∏è @FormatTime(elapsedTime)
            </div>
        }
        <div class="size-buttons">
            @for (int size = 4; size <= 10; size++)
            {
                var s = size;
                <button class="size-btn @(boardSize == s ? "active" : "")" 
                        @onclick="() => ChangeBoardSize(s)"
                        disabled="@isGenerating">
                    @(s)x@(s)
                </button>
            }
        </div>
        <button @onclick="ClearBoard" disabled="@isGenerating">Clear</button>
    </div>

    @if (isGenerating)
    {
        <div class="spinner-container">
            <div class="spinner">‚è≥</div>
            <p>Generating @(boardSize)x@(boardSize) board...</p>
            <p style="font-size: 14px; color: #999;">Attempt @currentAttempt...</p>
            
            @if (generationLog.Count > 0)
            {
                <div class="generation-log" id="generation-log">
                    @foreach (var log in generationLog)
                    {
                        <div class="log-entry">@log</div>
                    }
                </div>
            }
        </div>
    }

    @if (!isGenerating && currentGameNumber > 0)
    {
        <h2 style="margin-top: 20px; color: #2196F3;">@(boardSize)x@(boardSize) Game #@currentGameNumber</h2>
    }

    <div class="board" style="grid-template-columns: repeat(@boardSize, 1fr); --board-size: @boardSize; @(isGenerating ? "display: none;" : "")">
        @for (int row = 0; row < boardSize; row++)
        {
            @for (int col = 0; col < boardSize; col++)
            {
                var r = row;
                var c = col;
                var region = gameState.Regions[row, col];
                var cellState = gameState.Board[row, col];
                var isAutoMark = gameState.AutoMarks[row, col];
                var hasConflict = gameState.HasConflict(row, col);
                
                <div class="cell region-@region @(hasConflict ? "conflict" : "")"
                     @onclick="() => ToggleQueen(r, c)"
                     @onpointerdown="(e) => HandleCellPointerDown(e, r, c)"
                     @onpointerenter="() => HandleCellPointerEnter(r, c)"
                     @onpointerup="HandleCellPointerUp"
                     @onpointercancel="HandleCellPointerUp"
                     @oncontextmenu:preventDefault="true">
                    @if (cellState == CellState.ManualCross || isAutoMark)
                    {
                        <span class="cross @(isAutoMark ? "auto" : "")">‚úï</span>
                    }
                    else if (cellState == CellState.Queen)
                    {
                        <span class="queen">‚ôõ</span>
                    }
                </div>
            }
        }
    </div>

    <div class="toggles-container">
        <label class="toggle-label" @onclick="ToggleAutoMark" @onclick:preventDefault="true">
            <span>Auto-mark invalid squares</span>
            <div class="toggle-switch">
                <input type="checkbox" checked="@autoMarkInvalid" disabled="@isGenerating" />
                <span class="toggle-slider"></span>
            </div>
        </label>
        
        <label class="toggle-label" @onclick="ToggleTimedMode" @onclick:preventDefault="true">
            <span>Timed games</span>
            <div class="toggle-switch">
                <input type="checkbox" checked="@timedMode" />
                <span class="toggle-slider"></span>
            </div>
        </label>
    </div>

    @if (gameState.CheckWin() || isGameWon)
    {
        <div class="win-overlay" @onclick="CloseWinOverlay">
            <div class="win-message" @onclick:stopPropagation="true">
                üéâ Congratulations! üéâ
                <br />
                @if (timedMode)
                {
                    <span style="font-size: 18px; display: block; text-align: center; margin-top: 10px;">Solved in @FormatTime(completionTime ?? elapsedTime)!</span>
                }
                <button class="new-game-btn" @onclick="StartNewGame">New Game</button>
            </div>
        </div>
    }
</div>

@code {
    private int boardSize = 6;
    private GameState gameState = null!;
    private bool autoMarkInvalid = true;
    private bool isGenerating = false;
    private System.Timers.Timer? gameTimer;
    private DateTime gameStartTime;
    private TimeSpan elapsedTime;
    private TimeSpan? completionTime;
    private bool isGameWon = false;
    private List<string> generationLog = new List<string>();
    private int currentAttempt = 0;
    private int currentGameNumber = 0;
    private bool timedMode = true;
    private bool pointerIsDown = false;
    private (int row, int col)? pointerDownCell = null;
    private HashSet<(int row, int col)> draggedCells = new HashSet<(int, int)>();

    protected override void OnInitialized()
    {
        // Read board size from URL parameter
        var uri = new Uri(NavigationManager.Uri);
        var query = System.Web.HttpUtility.ParseQueryString(uri.Query);
        var sizeParam = query["size"];
        var testWin = query["testWin"];
        
        if (!string.IsNullOrEmpty(sizeParam) && int.TryParse(sizeParam, out int size))
        {
            if (size >= 4 && size <= 10)
            {
                boardSize = size;
            }
        }
        
        gameState = new GameState(boardSize);
        
        // Test mode: show win state immediately
        if (!string.IsNullOrEmpty(testWin) && testWin == "true")
        {
            isGameWon = true;
            completionTime = TimeSpan.FromSeconds(42);
            // Don't call ResetGame in test mode
        }
        else
        {
            ResetGame();
        }
    }

    public void Dispose()
    {
        gameTimer?.Stop();
        gameTimer?.Dispose();
    }

    private void StartTimer()
    {
        if (!timedMode)
            return;
            
        completionTime = null;
        isGameWon = false;
        gameStartTime = DateTime.Now;
        elapsedTime = TimeSpan.Zero;
        
        gameTimer?.Stop();
        gameTimer = new System.Timers.Timer(100); // Update every 100ms for smooth display
        gameTimer.Elapsed += (sender, e) =>
        {
            if (!isGameWon)
            {
                elapsedTime = DateTime.Now - gameStartTime;
                InvokeAsync(StateHasChanged);
            }
        };
        gameTimer.Start();
    }

    private void StopTimer()
    {
        gameTimer?.Stop();
        completionTime = elapsedTime;
        isGameWon = true;
        
        // Only add to game history if in timed mode
        if (timedMode)
        {
            GameHistory.AddResult(boardSize, currentGameNumber, completionTime.Value);
        }
    }

    private string FormatTime(TimeSpan time)
    {
        if (time.TotalHours >= 1)
            return $"{(int)time.TotalHours}:{time.Minutes:D2}:{time.Seconds:D2}";
        else
            return $"{time.Minutes}:{time.Seconds:D2}";
    }

    private async Task ChangeBoardSize(int newSize)
    {
        // If clicking current size, treat it as "New Game"
        bool isSameSize = (newSize == boardSize);

        // Check if user has placed anything (and game is not won)
        bool hasPlacedPieces = false;
        if (!isGameWon)
        {
            for (int r = 0; r < boardSize; r++)
            {
                for (int c = 0; c < boardSize; c++)
                {
                    if (gameState.Board[r, c] != CellState.Empty)
                    {
                        hasPlacedPieces = true;
                        break;
                    }
                }
                if (hasPlacedPieces) break;
            }
        }

        // Ask for confirmation if pieces are placed and game is not won
        if (hasPlacedPieces)
        {
            string message = isSameSize 
                ? "Generate a new puzzle? Your current progress will be lost." 
                : "Changing board size will clear your current progress. Continue?";
            
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", message);
            if (!confirmed)
                return;
        }

        // Update size and create new game state
        boardSize = newSize;
        gameState = new GameState(boardSize);
        
        // Update URL with new size
        NavigationManager.NavigateTo($"?size={boardSize}", false);
        
        // Now show spinner and generate
        isGenerating = true;
        StateHasChanged();
        await Task.Delay(100);

        await ResetGameAsync();
    }

    private async void ResetGame()
    {
        await ChangeBoardSize(boardSize);
    }

    private async Task ResetGameAsync()
    {
        // Don't set isGenerating again if already set by ChangeBoardSize
        if (!isGenerating)
        {
            isGenerating = true;
            StateHasChanged();
            await Task.Delay(100);
        }

        // Increment game counter for this board size
        currentGameNumber = GameHistory.GetNextGameNumber(boardSize);

        generationLog.Clear();
        currentAttempt = 0;
        
        bool foundValid = false;
        
        await Task.Run(async () =>
        {
            int maxAttempts = boardSize >= 10 ? 50 : 100;
            
            for (int attempts = 0; attempts < maxAttempts; attempts++)
            {
                int attemptNum = attempts + 1;
                currentAttempt = attemptNum;
                
                await InvokeAsync(() =>
                {
                    AddLog($"Attempt {attemptNum}: Generating regions...");
                    StateHasChanged();
                });
                
                await Task.Delay(20); // Small delay for UI update
                
                var regions = BoardGenerator.GenerateRegions(boardSize);
                
                await InvokeAsync(() =>
                {
                    AddLog($"Attempt {attemptNum}: Validating...");
                    StateHasChanged();
                });
                
                await Task.Delay(20); // Small delay for UI update
                
                if (BoardGenerator.IsSolvable(regions, boardSize))
                {
                    await InvokeAsync(() =>
                    {
                        gameState.SetRegions(regions);
                        AddLog($"‚úì Attempt {attemptNum}: Valid board found!");
                        foundValid = true;
                        StateHasChanged();
                    });
                    break;
                }
                else
                {
                    await InvokeAsync(() =>
                    {
                        AddLog($"‚úó Attempt {attemptNum}: No solution exists");
                        StateHasChanged();
                    });
                }
                
                await Task.Delay(20); // Small delay between attempts
            }
            
            if (!foundValid)
            {
                await InvokeAsync(() =>
                {
                    AddLog($"‚ö† Using best attempt after {currentAttempt} tries");
                    StateHasChanged();
                });
            }
        });

        isGenerating = false;
        StateHasChanged();
        
        // Start the timer after board is generated
        StartTimer();
    }
     
    private void AddLog(string message)
    {
        generationLog.Add(message);
        // Keep up to 50 messages for better scrolling effect
        if (generationLog.Count > 50)
            generationLog.RemoveAt(0);
    }

    private void ToggleQueen(int row, int col)
    {
        // Ignore clicks if game is won or if we just did a drag operation
        if (isGameWon)
            return;
            
        // If we just finished a drag, ignore this click and clear the flag
        if (draggedCells.Count > 0)
        {
            draggedCells.Clear();
            StateHasChanged(); // Force UI update after clearing drag state
            return;
        }
            
        var oldState = gameState.GetCell(row, col);
        bool wasAutoMark = gameState.GetAutoMark(row, col);
        
        // If clicking on an auto-mark, convert it to manual mark
        if (wasAutoMark && oldState == CellState.Empty)
        {
            gameState.SetAutoMark(row, col, false);
            gameState.SetCell(row, col, CellState.ManualCross);
            return;
        }
        
        // If this was a queen being removed, clear its auto-marks
        if (oldState == CellState.Queen)
        {
            gameState.RemoveAutoMarksFromQueen(row, col);
        }
        
        // Cycle through: Empty -> ManualCross -> Queen -> Empty
        var nextState = oldState switch
        {
            CellState.Empty => CellState.ManualCross,
            CellState.ManualCross => CellState.Queen,
            CellState.Queen => CellState.Empty,
            _ => CellState.Empty
        };
        gameState.SetCell(row, col, nextState);
        
        // If we just placed a queen and auto-mark is enabled, mark invalid squares
        if (autoMarkInvalid && oldState != CellState.Queen && nextState == CellState.Queen)
        {
            gameState.AutoMarkInvalidSquares(row, col);
        }
        
        // Check for win condition
        if (!isGameWon && gameState.CheckWin())
        {
            StopTimer();
        }
    }
    
    private void ToggleAutoMark()
    {
        if (!isGenerating)
        {
            autoMarkInvalid = !autoMarkInvalid;
        }
    }
    
    private void ToggleTimedMode()
    {
        timedMode = !timedMode;
    }
    
    private void CloseWinOverlay()
    {
        // Clicking on the overlay background closes it
        isGameWon = false;
    }
    
    private async void StartNewGame()
    {
        // Close the overlay and start a new game (no confirmation needed)
        completionTime = null;
        
        // Generate new game directly without confirmation
        gameState = new GameState(boardSize);
        
        isGenerating = true;
        isGameWon = false;
        StateHasChanged();
        await Task.Delay(100);

        await ResetGameAsync();
    }
    
    private async void ClearBoard()
    {
        // Check if user has placed anything
        bool hasPlacedPieces = false;
        if (!isGameWon)
        {
            for (int r = 0; r < boardSize; r++)
            {
                for (int c = 0; c < boardSize; c++)
                {
                    if (gameState.Board[r, c] != CellState.Empty)
                    {
                        hasPlacedPieces = true;
                        break;
                    }
                }
                if (hasPlacedPieces) break;
            }
        }

        // Ask for confirmation if pieces are placed
        if (hasPlacedPieces)
        {
            bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Clear all your marks and start fresh on this board?");
            if (!confirmed)
                return;
        }

        // Clear the board without regenerating
        for (int r = 0; r < boardSize; r++)
        {
            for (int c = 0; c < boardSize; c++)
            {
                gameState.SetCell(r, c, CellState.Empty);
                gameState.SetAutoMark(r, c, false);
            }
        }
        
        // Restart the timer
        if (timedMode)
        {
            StartTimer();
        }
    }
    
    private void HandleCellPointerDown(PointerEventArgs e, int row, int col)
    {
        if (isGameWon)
            return;
            
        pointerIsDown = true;
        pointerDownCell = (row, col);
    }
    
    private void HandleCellPointerEnter(int row, int col)
    {
        if (!pointerIsDown || isGameWon)
            return;
            
        // We've moved to a different cell - this is a drag operation
        if (pointerDownCell.HasValue)
        {
            // Mark the initial cell if we haven't already
            if (draggedCells.Count == 0)
            {
                draggedCells.Add(pointerDownCell.Value);
                PlaceMarkIfEmpty(pointerDownCell.Value.row, pointerDownCell.Value.col);
            }
        }
        
        // Only mark if we haven't marked this cell yet during this drag
        if (draggedCells.Add((row, col)))
        {
            PlaceMarkIfEmpty(row, col);
        }
    }
    
    private void HandleCellPointerUp()
    {
        pointerIsDown = false;
        pointerDownCell = null;
        // Don't clear draggedCells here - it's used in ToggleQueen to detect drag
    }
    
    private void PlaceMarkIfEmpty(int row, int col)
    {
        var cellState = gameState.GetCell(row, col);
        bool isAutoMark = gameState.GetAutoMark(row, col);
        
        // Only place marks on empty cells or auto-marks, don't overwrite queens or existing manual marks
        if (cellState == CellState.Empty && !isAutoMark)
        {
            gameState.SetCell(row, col, CellState.ManualCross);
        }
        else if (isAutoMark && cellState == CellState.Empty)
        {
            gameState.SetAutoMark(row, col, false);
            gameState.SetCell(row, col, CellState.ManualCross);
        }
    }
}
